from __future__ import annotations

from PyQt6.QtWidgets import QWidget, QSizePolicy, QTableView
from PyQt6.QtCore import pyqtSlot
from vspreview.core import Frame, PushButton, VBoxLayout, HBoxLayout, SpinBox, ProgressBar, LineEdit
from vspreview.core.custom import ComboBox, TableModel
from vspreview.plugins import MappedNodesPlugin, PluginConfig, PluginGraphicsView
from vstools import vs

from tqdm import tqdm
import math
import os
import cv2
import numpy as np
from PIL import Image

np.set_printoptions(suppress=True)
import local

import threading

core = vs.core

__all__ = ["UndermixPlugin"]


class UndermixPlugin(MappedNodesPlugin, QWidget):
  _config = PluginConfig("moe.grass", "undermix")

  def setup_ui(self) -> None:
    self.view = PluginGraphicsView(self)

    self.start_n = SpinBox(minimum=0, maximum=100000)
    start_set = PushButton("Set", self, clicked=self.set_start)
    self.end_n = SpinBox(minimum=0, maximum=100000)
    end_set = PushButton("Set", self, clicked=self.set_end)

    self.start_n.setValue(7406)
    self.end_n.setValue(7477)

    analyze = PushButton("Analyze", self, clicked=self.analyze)

    self.outpath = LineEdit("stitched.png")
    self.outpath.setSizePolicy(QSizePolicy.Policy.Preferred,
                               QSizePolicy.Policy.Preferred)
    self.rendermode = ComboBox()
    self.rendermode.addItems(["median"])
    self.rendermode.setCurrentIndex(0)
    render = PushButton("Render", self, clicked=self.render)

    self.progress = ProgressBar()
    self.progress.setTextVisible(True)

    self.table_offsets = QTableView(None)
    self.table_offsets.setModel(TableModel([], ["x", "y"], True))
    self.table_offsets.setSizePolicy(QSizePolicy.Policy.Minimum,
                                     QSizePolicy.Policy.Preferred)

    hbox = HBoxLayout(None,
                      [self.start_n, start_set, self.end_n, end_set, analyze])
    hbox2 = HBoxLayout(None, [self.outpath, self.rendermode, render])

    hbox3 = HBoxLayout(None, [self.table_offsets, self.view])
    VBoxLayout(self, [hbox3, self.progress, hbox, hbox2])

    self.features = {}
    self.transforms = {}
    self.offsets_xy = {}
    self.width = None
    self.height = None

  def set_start(self):
    self.start_n.setValue(self.main.current_output.last_showed_frame)

  def set_end(self):
    self.end_n.setValue(self.main.current_output.last_showed_frame)

  def render(self):
    self.analyze()
    node = self.main.current_output.prepared.original_clip
    node = core.resize.Point(node, format=vs.RGB24)

    rendermode = self.rendermode.currentIndex()
    start = self.start_n.value()
    end = self.end_n.value()
    total = end - start
    output_filename = self.outpath.text() or "stitched.png"

    rotated_images = {}

    self.update_progress(0, total, "Rotating frames")

    for i in range(start, end + 1):
      (warp_matrix, size) = self.transforms[i]
      frame = node.get_frame(i)

      im = np.ctypeslib.as_array(frame).swapaxes(0, 2).swapaxes(0, 1)
      im = im.copy(order="C")
      im = im.reshape((node.height, node.width, 3))
      im = cv2.cvtColor(im, cv2.COLOR_RGB2RGBA)

      # pad
      im = np.vstack([im[:1, :, :], im, im[-1:, :, :]])
      im = np.vstack([im[:1, :, :], im, im[-1:, :, :]])
      im = np.hstack([im[:, :1, :], im, im[:, -1:, :]])
      im = np.hstack([im[:, :1, :], im, im[:, -1:, :]])

      mask_im = im.copy()
      mask_im[:1, :, 3] = 0
      mask_im[-1:, :, 3] = 0
      mask_im[:, :1, 3] = 0
      mask_im[:, -1:, 3] = 0

      im = cv2.warpAffine(im,
                          warp_matrix,
                          size,
                          flags=cv2.INTER_CUBIC + cv2.WARP_INVERSE_MAP,
                          borderMode=cv2.BORDER_REPLICATE).astype(np.float64)

      mask = cv2.warpAffine(mask_im,
                            warp_matrix,
                            size,
                            flags=cv2.INTER_CUBIC + cv2.WARP_INVERSE_MAP)

      im[:, :, 3] = mask[:, :, 3]
      rotated_images[i] = im

      self.update_progress(i - start, total, "Rotating frames")

    offsets_xy = [self.offsets_xy[k] for k in rotated_images]
    offsets_xy = np.array(offsets_xy, dtype=np.float64)

    rotated_images = list(rotated_images.values())

    def update_prog(c):
      if c == self.height:
        self.update_progress(c, c, "Done")
      else:
        self.update_progress(c + 1, self.height, "Rendering")

    self.update_progress(0, self.height, "Rendering")

    def render(rotated_images, offsets_xy, width, height, update, path):
      im = local.test(rotated_images, offsets_xy, width, height, update)
      path2 = path
      n = 1
      while os.path.exists(path2):
        a, b = os.path.splitext(path)
        path2 = f"{a}{n}{b}"
        n += 1

      Image.fromarray(im.astype(np.uint8)).save(path2)
      update(height)

    t = threading.Thread(target=render,
                         args=[
                             rotated_images, offsets_xy, self.width,
                             self.height, update_prog, output_filename
                         ],
                         daemon=True)

    t.start()

  @pyqtSlot(int)
  def update_progress(self, c, total, text):
    self.progress.setValue(c)
    self.progress.setMaximum(total)
    self.progress.setFormat(f"{text}: {c}/{total}")
    self.progress.update()

  def get_features(self, f, n):
    if n in self.features:
      return self.features[n]
    orb = cv2.ORB_create(500)
    gray = np.ctypeslib.as_array(f).reshape((1080, 1920)).copy(order="C")
    self.features[n] = orb.detectAndCompute(gray, None)
    return self.features[n]

  def get_node(self, node):
    if node.format.id == vs.GRAY32: return node

    gray = core.resize.Bicubic(node, format=vs.GRAY8, matrix_s="709")
    gray = core.std.RemoveFrameProps(gray, "_Matrix")
    gray = core.std.Sobel(gray)

    def points(n, f):
      im = np.ctypeslib.asarray(f[0]).swapaxes(0, 2).swapaxes(0, 1)
      im = im.copy(order="C")

      kp, des = self.get_features(f[1], n)
      im = cv2.drawKeypoints(im, kp, None, color=(255, 0, 0), flags=0)

      f = f[0].copy()
      np.copyto(np.asarray(f[0]), im[:, :, 0])
      np.copyto(np.asarray(f[1]), im[:, :, 1])
      np.copyto(np.asarray(f[2]), im[:, :, 2])
      return f

    node = core.resize.Bicubic(node, format=vs.RGB24, matrix_in_s="709")

    if self.width == None:
      node = core.std.ModifyFrame(clips=[node, gray],
                                  clip=node,
                                  selector=points)
      return node

    resized = core.resize.Bicubic(node, width=self.width, height=self.height)

    def rotate(n, f):
      if n not in self.transforms:
        return f[1]

      im = np.ctypeslib.asarray(f[0]).swapaxes(0, 2).swapaxes(0, 1)
      im = im.copy(order="C")

      kp, des = self.features[n]
      im = cv2.drawKeypoints(im, kp, None, color=(255, 0, 0), flags=0)

      (warp_matrix, size) = self.transforms[n]

      im = cv2.warpAffine(im,
                          warp_matrix,
                          size,
                          flags=cv2.INTER_CUBIC + cv2.WARP_INVERSE_MAP,
                          borderMode=cv2.BORDER_CONSTANT).astype(np.uint8)

      im2 = np.zeros((f[1].height, f[1].width, 3), np.uint8)

      x, y = self.offsets_xy[n]

      x = int(round(x))
      y = int(round(y))
      x2 = x + im.shape[1]
      y2 = y + im.shape[0]

      x = max(x, 0)
      y = max(y, 0)
      x2 = min(x2, f[1].width)
      y2 = min(y2, f[1].height)

      im2[y:y2, x:x2] = im[:y2 - y, :x2 - x]

      f = f[1].copy()
      np.copyto(np.asarray(f[0]), im2[:, :, 0])
      np.copyto(np.asarray(f[1]), im2[:, :, 1])
      np.copyto(np.asarray(f[2]), im2[:, :, 2])
      return f

    resized = core.std.BlankClip(resized)
    node = core.std.ModifyFrame(clips=[node, resized],
                                clip=resized,
                                selector=rotate)

    return node

  def analyze(self):
    node = self.main.current_output.prepared.original_clip

    gray = core.resize.Bicubic(node, format=vs.GRAY8, matrix_s="709")
    gray = core.std.RemoveFrameProps(gray, "_Matrix")
    gray = core.std.Sobel(gray)

    features = {}
    warp_matrices = {}
    offsets = {}
    warp_matrices_cum = {}

    start = self.start_n.value()
    end = self.end_n.value()
    total = end - start

    if end <= start: return

    self.update_progress(0, total, "Features")

    for i in range(start, end + 1):
      f = gray.get_frame(i)
      self.get_features(f, i)
      self.update_progress(i - start, total, "Features")

    # feature matching
    index_params = dict(
        algorithm=6,
        table_number=6,  # 12
        key_size=12,  # 20
        multi_probe_level=1)
    search_params = dict(checks=50)
    flann = cv2.FlannBasedMatcher(index_params, search_params)
    bf = cv2.BFMatcher(cv2.NORM_HAMMING, crossCheck=True)

    def feature_matching(i1, i2):
      kp1, des1 = self.features[i1]
      kp2, des2 = self.features[i2]

      matches2to1 = flann.knnMatch(des2, des1, k=2)
      recip_matches = flann.knnMatch(des1, des2, k=2)

      matchesMask_ratio = [[0, 0] for i in range(len(matches2to1))]
      match_dict = {}
      for i, d in enumerate(matches2to1):
        if len(d) < 2: continue
        m, n = d

        if m.distance < 0.7 * n.distance:
          matchesMask_ratio[i] = [1, 0]
          match_dict[m.trainIdx] = m.queryIdx

      good = []
      matchesMask_ratio_recip = [[0, 0] for i in range(len(recip_matches))]

      for i, d in enumerate(recip_matches):
        if len(d) < 2: continue
        m, n = d
        if m.distance < 0.7 * n.distance:  # ratio
          if m.queryIdx in match_dict and match_dict[
              m.queryIdx] == m.trainIdx:  #reciprocal
            good.append(m)
            matchesMask_ratio_recip[i] = [1, 0]

      return ([kp1[m.queryIdx].pt
               for m in good], [kp2[m.trainIdx].pt for m in good])

    def get_transform(i1, i2):
      pts1, pts2 = feature_matching(i1, i2)

      src_pts = np.float32(pts1).reshape(-1, 1, 2)
      dst_pts = np.float32(pts2).reshape(-1, 1, 2)

      M, mask = cv2.estimateAffinePartial2D(src_pts,
                                            dst_pts,
                                            cv2.USAC_MAGSAC,
                                            ransacReprojThreshold=5.0)
      #M[0, 0] = 1
      #M[0, 1] = 0
      #M[0, 2] = 0
      #print(M)
      return M

    self.update_progress(0, total, "Transforms")
    for i in range(start + 1, end + 1):
      warp_matrices[i] = get_transform(i - 1, i)
      self.update_progress(i - start, total, "Transforms")

    running_total_matrix = np.eye(3, 3, dtype=np.float64)

    sz = (node.height, node.width)

    self.update_progress(i - start, total, "Cumulative")
    for i in range(start + 1, end + 1):
      wm = np.copy(warp_matrices[i])

      tempwarp = np.vstack([wm, np.array([0, 0, 1])])
      running_total_matrix = tempwarp.dot(running_total_matrix)
      warp_matrices_cum[i] = running_total_matrix

      warp_matrix = warp_matrices_cum[i][0:2].astype(np.float64)
      c = np.vstack((warp_matrix, [0, 0, 1]))
      c_inv = np.linalg.inv(c)[:2]

      points = [[0, 0], [sz[1], 0], [0, sz[0]], [sz[1], sz[0]]]
      points = [c_inv.dot([p[0], p[1], 1]) for p in points]

      x_min = min([p[0] for p in points])
      x_max = max([p[0] for p in points])
      y_min = min([p[1] for p in points])
      y_max = max([p[1] for p in points])

      left_padding = x_min
      right_padding = x_max - sz[1]
      top_padding = y_min
      bottom_padding = y_max - sz[0]

      offsets[i] = (left_padding, top_padding, x_max, y_max)

      offset_trans = np.eye(3, 3, dtype=np.float64)
      offset_trans[0, 2] = left_padding
      offset_trans[1, 2] = top_padding
      new_warp_matrix = np.vstack([warp_matrix, np.array([0, 0, 1])])

      new_warp_matrix = new_warp_matrix.dot(offset_trans)[:2]

      # (running matrix, (width, height))
      self.transforms[i] = (new_warp_matrix,
                            (int(sz[1] + right_padding - left_padding),
                             int(sz[0] + bottom_padding - top_padding)))

      self.update_progress(i - start, total, "Cumulative")

    left = math.floor(round(min([o[0] for o in offsets.values()]), 4))
    top = math.floor(round(min([o[1] for o in offsets.values()]), 4))
    right = math.ceil(round(max([o[2] for o in offsets.values()]), 4))
    bottom = math.ceil(round(max([o[3] for o in offsets.values()]), 4))

    self.transforms[start] = (np.array([[1, 0, 0], [0, 1, 0]],
                                       dtype=np.float64), (1920, 1080))
    self.width = right - left
    self.height = bottom - top

    self.offsets_xy = {
        o: (offsets[o][0] - left, offsets[o][1] - top)
        for o in offsets
    }

    self.offsets_xy[start] = (-left, -top)

    data = [[f"{self.offsets_xy[i][0]:.8f}", f"{self.offsets_xy[i][1]:.8f}"]
            for i in sorted(self.offsets_xy.keys())]

    self.table_offsets.setModel(TableModel(data, ["x", "y"], True))

    self.progress.setFormat(None)

    self.reset()

  def on_current_frame_changed(self, frame: Frame) -> None:
    frame = self.outputs.current.to_frame(
        self.main.current_output.to_time(frame))
    self.outputs.current.render_frame(frame, None, None,
                                      self.view.current_scene)

    start = self.start_n.value()
    row = frame - start
    model = self.table_offsets.model()
    if model == None:
      return
    if row >= 0 and row < model.rowCount(self.table_offsets):
      self.table_offsets.selectRow(row)
    else:
      self.table_offsets.clearSelection()

  def on_current_output_changed(self, cur, prev):
    self.start_n.setMaximum(
        self.main.current_output.prepared.original_clip.num_frames)
    self.end_n.setMaximum(
        self.main.current_output.prepared.original_clip.num_frames)
    self.on_current_frame_changed(self.main.current_output.last_showed_frame)

  def init_outputs(self) -> None:
    assert self.main.outputs
    self.outputs.clear()
